#include <unistd.h>
#include <getopt.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include "${PROJ}yopts.h"

#ifdef YDEBUG
#define dprint	printf
int main(int argc, char **argv)
{
	int ret;

	ret = ${PROJ}yopts_parse(argc, argv);
	printf("Parser returned %d (left %d(%s)... options)\n", ret, yopt_tail, argv[yopt_tail]);

	return ret;
}
#else
#define dprint(...)
#endif

struct yopts ${PROJ}yopts = {
	${DEFAULTS}
};

int yopt_tail;

static int yopt_err = YOPTS_PARSE_OK;
static const int yopt_nr_args = ${NR_ARGS};
static int yopt_next_arg = 0;

#define YOPTARG_SET	((char *)-1)

void ${PROJ}yopts_usage(char *prog)
{
	printf("Usage:\n"
${USAGE},
	prog);
}

__attribute__((weak)) void yopt_print(const char *format, ...)
{
        va_list params;

        va_start(params, format);
        fprintf(stderr, format, params);
        va_end(params);
}

__attribute__((weak)) void *yopt_realloc(void *ptr, unsigned long size)
{
	return realloc(ptr, size);
}

static inline void *yopt_realloc_mem(void *ptr, unsigned long size)
{
	void *ret;

	ret = yopt_realloc(ptr, size);
	if (!ret)
		yopt_err = YOPTS_PARSE_ERR;

	return ret;
}

static inline unsigned int yopt_parse_int(char *str)
{
	char *aux;
	unsigned int ret;

	ret = strtol(str, &aux, 0);
	if (*aux != '\0')
		yopt_err = YOPTS_PARSE_ERR;

	return ret;
}

struct yopt_set {
	const char *s;
	const struct option *l;
	int (*assign)(int opt, char **argv);
};

static int generic_assign(int opt, char **argv);
static int yopts_parse_arg(char *arg);

static int def_assign(int opt, char **argv, bool generic)
{
	if (generic) {
		if (opt == 1)
			return yopts_parse_arg(argv[optind - 1]);

		yopt_err = YOPTS_PARSE_ERR;
		return 0;
	}

	return generic_assign(opt, argv);
}

${YSETS}

static struct yopt_set *ycur = &generic_set;

static int yopts_fixup_choices(void)
{
	yopt_err = YOPTS_PARSE_OK;

${FIX_CHOICES}
	return yopt_err;
}

static int yopts_parse_arg(char *arg)
{
	bool new_set = false;

	switch (yopt_next_arg) {
${ASSIGN_ARGS}
	}

	yopt_next_arg++;
	if (yopt_next_arg == yopt_nr_args)
		return 1;
	if (new_set)
		return 2;
	return 0;
}

static int yopts_check_args(void)
{
	yopt_err = YOPTS_PARSE_OK;

${CHECK_ARGS}
	return yopt_err;
}

static int yopts_check_reqs(void)
{
	yopt_err = YOPTS_PARSE_OK;

${CHECK_REQS}
	return yopt_err;
}

int ${PROJ}yopts_parse(int argc, char **argv)
{
	int opt, idx, ret = YOPTS_PARSE_OK;
	bool permutate = false;

	if (!yopt_nr_args)
		permutate = true;

	while (1) {
		opt = getopt_long(argc, argv, ycur->s + (permutate ? 1 : 0), ycur->l, &idx);
		if (opt == -1)
			break;
		if ((opt == 1) && permutate) {
			yopt_print("YODA: Internal error. Plz, report to developers.\n");
			return YOPTS_PARSE_ERR;
		}

		opt = ycur->assign(opt, argv);

		if (${PROJ}yopts.version)
			return YOPTS_PARSE_SPECIAL;

		if (${PROJ}yopts.help)
			yopt_err = YOPTS_PARSE_SPECIAL;

		if (yopt_err) {
			if (!yopt_next_arg)
				${PROJ}yopts_usage(argv[0]);
			return yopt_err;
		}

		if (opt) {
			if (opt < 0) {
				ret = YOPTS_PARSE_SPECIAL;
				break;
			}

			dprint("Switching opt array (%d)\n", opt);
			/* reset getopt_long to normal (permutating) scan */
			optind--;
			argc -= optind;
			argv += optind;
			yopt_tail += optind;
			optind = 0;
			if (opt != 2) {
				dprint("Reset arg scan to permutating\n");
				permutate = true;
			}
		}
	}

	yopt_tail += optind;

	if (ret == YOPTS_PARSE_OK) {
		yopt_err = yopts_check_args();
		if (yopt_err)
			return yopt_err;
	}

	yopt_err = yopts_fixup_choices();
	if (yopt_err)
		return yopt_err;

	yopt_err = yopts_check_reqs();
	if (yopt_err)
		return yopt_err;

	return ret;
}
